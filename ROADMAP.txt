================================================================================
  GRAPH EDITOR — DEVELOPMENT ROADMAP
  Last updated: 2026-02-25
================================================================================


================================================================================
  COMPLETED
================================================================================

Phase 1  ✓  Shell
             GLFW + GLAD + ImGui docking, game loop, FPS counter.

Phase 2  ✓  Renderer
             Camera orbit/pan/zoom, ground grid, VAO/VBO lit rendering.
             UE5-style infinite procedural grid with 4-level adaptive LOD.
             Procedural concrete tile texture (smooth centre, noisy edges,
             grout lines) in GLSL — no texture assets required.
             Light blue-grey colour palette.
             Grid depth-testing fixed (gl_FragDepth from Y=0 hit point).
             Zoom tracks mouse position on grid plane (map-zoom style).
             Tighter near plane (0.01) and minimum zoom distance (0.05).

Phase 3  ✓  Grammar Library (core)
             Grammar extracted into lib/ with zero GL/ImGui dependency.
             Animated step-by-step generation visible in viewport.
             Area validation and minPrim enforcement for room-shaped loops.
             GrammarInducer: learns tile grammar from hand-crafted example.

Phase 4  ✓  SceneObject
             Transform + mesh ref + socket list. Grammar populates scene
             instead of owning its placed[] array. MeshLibrary shared pool.

Phase 5a ✓  OBJ + GLTF Import
             Multi-file native Windows file dialog.
             ObjImporter: v/vn/vt/f, triangulates quads, flat normals.
             GltfImporter: binary and ASCII GLTF/GLB support.

Phase 6  ✓  Selection + 3D Cursor
             Ray-cast against Y=0 plane, hover highlight, click selection,
             properties panel with transform inspector.

Phase 7  ✓  Asset Library
             Persistent store (editor_assets.json) separate from Scene.
             Per-asset calibration transform (offset / rotation / scale).
             128x128 thumbnail renderer using offscreen FBO.
             4-per-row scrollable grid viewer.
             Multi-select: Click / Ctrl+Click / Shift+Click / Select All.
             Calibration presets: Reset, Z-up to Y-up, -Z forward.
             Add to Scene places instances with calibration baked in.

Phase 8  ✓  Project File
             JSON save/load of the entire scene (ProjectFile.cpp).

Phase 9  ✓  Editor UI Polish
             All panels hidden on launch except Scene view.
             History list removed from Scene panel (undo/redo still on Ctrl+Z/Y).
             UE5-style toolbar with Play/Stop, gizmo mode buttons.
             Panel alpha fade when interacting with the scene.
             Status toast notifications.
             COMMANDS.txt reference listing all 43 commands and shortcuts.

Phase 10 ✓  Gizmo + Multi-Object Transform
             ImGuizmo translate/rotate/scale gizmo on selected object.
             Multi-select transform: all selected objects move together.
             Command history with undo/redo stack.
             Copy/paste/delete selection.
             Merge Selected and Merge + Weld Vertices.
             Snap to Grid and Fit to Grid Cell.
             Half-Edge Mesh split builder.


================================================================================
  REMAINING — RECOMMENDED ORDER
================================================================================


--------------------------------------------------------------------------------
  ARCHITECTURE REFACTOR  (do this before new feature phases)
--------------------------------------------------------------------------------

Refactor A  ✓  Editor Mode System
             EditorMode enum: EDITOR / PLAY / GRAPH_GRAMMAR.
             Mode transitions fire exactly once per switch (prevMode tracking).
             Panel visibility swaps on mode change (showAssetLibrary,
             showGrammarView, showGraphViewer all wired to mode transitions).
             Mode indicator in toolbar (colour-coded label).
             Grammar toggle button in toolbar (G shortcut).
             ToolbarSection extended with multi-mode visibility (Refactor A final):
               - visibleInEditor / visibleInGrammar flags replace single requiredMode.
               - Static factories: forMode(), editorOnly(), grammarOnly(), alwaysVisible().
               - sectionVisible() helper in EditorUI.cpp dispatches both old and new paths.
               - Backwards compatible with existing Refactor C registrations.

Refactor B  ✓  Grammar Library Split — TWO SEPARATE LIBRARIES
             lib/grammar-core/  Grammar.h/.cpp, GrammarInducer.h/.cpp,
                                HalfEdgeMesh.h/.cpp — zero GL/ImGui dependency.
             lib/grammar-ui/    GrammarView.h/.cpp — ImGui panels, depends on
                                grammar-core + ImGui + Scene + Renderer.
             src/ no longer contains any grammar files.
             Old flat lib/ files archived to lib/legacy/ (not compiled).


Refactor C  ✓  Grammar Mode Toolbar
             ToolbarSection struct added to EditorUI.h with requiredMode +
             draw callback. EditorUI::registerToolbarSection() stores sections.
             Toolbar dispatch loop shows each section only when its mode matches.
             EDITOR section (Import, Gizmo T/R/S, Wireframe) hidden in GRAMMAR mode.
             GrammarView::drawToolbar() registered from App::init() — draws
             Generate / Reset / Step buttons when GRAPH_GRAMMAR mode is active.


--------------------------------------------------------------------------------
  FEATURE PHASES
--------------------------------------------------------------------------------

Refactor D  Background Task System + Progress Bar
             All long-running operations must run on a background thread
             and report progress to the UI without blocking the render loop.
             The UI must remain fully interactive (camera, selection, panels)
             while any task is running.

             TASKS THAT MUST BE MOVED TO BACKGROUND
             ────────────────────────────────────────
             The following operations currently block the main thread and
             must be migrated when this system is built:

               1. OBJ Import
                  ObjImporter::load() — file parse, normal computation.
                  Can be large for complex meshes.

               2. GLTF/GLB Import
                  GltfImporter — JSON parse, buffer decode, mesh build.
                  Binary buffers can be many MB.

               3. Mesh GPU Upload (asset->upload())
                  Must remain on main thread (GL context) but the CPU-side
                  parse and mesh build that precedes it can be offloaded.
                  Pattern: background builds MeshAsset data → main thread
                  calls upload() on completion.

               4. Thumbnail Generation
                  ThumbnailRenderer::renderThumbnail() — offscreen FBO render
                  per asset. Currently runs inline during import. With many
                  assets this causes a visible hitch.

               5. Project File Save
                  ProjectFile save — JSON serialise entire scene to disk.
                  Should never block a frame.

               6. Project File Load
                  ProjectFile load — JSON parse + all mesh reloads and
                  GPU uploads for every object in the scene.

               7. Grammar Generation
                  grammar::Grammar::stepGenerate() is already frame-spread
                  (m_animating loop) but the initial beginGenerate() setup
                  and the GrammarInducer::induceFromFile() call are blocking.
                  induceFromFile() in particular reads and parses a GEP file
                  plus runs rule inference — potentially slow on large examples.

               8. Merge + Weld Vertices
                  MeshMerge::mergeAndWeld() — vertex welding with tolerance
                  search is O(n²) for large meshes.

               9. Half-Edge Split Build
                  HalfEdgeMesh construction from a large merged mesh.

              10. Any future operations (asset pack scanning, large-world
                  streaming, grammar batch generation, export) must follow
                  the same pattern from the start.

             SYSTEM DESIGN
             ─────────────
             Introduce src/TaskSystem.h/.cpp:

               struct Task {
                   std::string      label;       // shown in progress bar
                   float            progress;    // 0.0 → 1.0
                   bool             done;
                   bool             failed;
                   std::string      errorMsg;
                   std::function<void()> onComplete;  // called on main thread
               };

               class TaskSystem {
                   void submit(std::shared_ptr<Task>);   // launches std::thread
                   void tick();       // call once per frame — fires onComplete
                   bool anyRunning(); // true if progress bar should show
                   // ... internal queue, mutex, condition_variable
               };

             Progress Bar UI (drawn by EditorUI each frame):
               - Rendered as a thin bar at the bottom of the viewport,
                 not a modal dialog — UI stays live.
               - Shows task label + percentage + animated spinner.
               - If multiple tasks are queued, shows "N tasks remaining".
               - Fades out smoothly when the last task completes.
               - Errors shown as a toast notification (existing system).

             Rules for new tasks going forward:
               - Any operation taking > ~50ms must use TaskSystem.
               - CPU work runs in background thread.
               - GL calls (upload, FBO render) are queued and flushed
                 on the main thread in TaskSystem::tick().
               - onComplete callback fires on main thread — safe to
                 update Scene, AssetLibrary, UI state.

Refactor E  Scene Outliner — Flat List → Tree Structure
             The current outliner is a flat scrollable list of SceneObjects.
             This breaks down as soon as objects are grouped — e.g. a
             building imported from a multi-mesh GLTF file, a grammar
             generation result owning 30 primitives, or a manually grouped
             set of props. The outliner must become a proper tree.

             DATA MODEL CHANGES (SceneObject + Scene)
             ──────────────────────────────────────────
             Add grouping support to SceneObject:

               struct SceneObject {
                   ...
                   int  parentId   = -1;           // -1 = root level
                   bool groupExpanded = true;       // outliner collapse state
                   // children are found by querying Scene for objects
                   // whose parentId == this->id  (no child list stored,
                   // avoids double-bookkeeping and dangling refs)
               };

             Add group operations to Scene:

               int  createGroup(const std::string& name);
               void setParent(int objectId, int parentId);  // -1 = unparent
               void reparent(int objectId, int newParentId);
               std::vector<int> childrenOf(int parentId) const;
               std::vector<int> rootObjects() const;  // parentId == -1

             Group node is itself a SceneObject with no mesh (mesh == nullptr).
             Deleting a group deletes or unparents its children (user choice).
             Transform hierarchy: child world transform = parent * local.
             SceneObject::transform() already returns world matrix —
             needs a worldTransform(Scene&) variant that walks the parent
             chain and multiplies.

             OUTLINER UI CHANGES (drawScenePanel)
             ──────────────────────────────────────
             Replace the flat BeginChild loop with a recursive tree draw:

               void drawOutlinerNode(int id, Scene& scene);
               // Uses ImGui::TreeNodeEx for groups (collapsible, arrow).
               // Uses ImGui::Selectable for leaf objects (no arrow).
               // Indentation handled by ImGui tree depth automatically.

             Features the tree outliner must support:
               - Expand / collapse groups with arrow toggle.
               - Select individual objects inside collapsed groups.
               - Shift+Click range select within the same level.
               - Ctrl+Click multi-select across levels.
               - Drag object onto group node to reparent (ImGui drag-drop).
               - Drag object to root level to unparent.
               - Right-click context menu:
                   Group Selected       (creates group, moves selected in)
                   Ungroup              (moves children to parent level)
                   Rename               (inline text edit)
                   Duplicate
                   Delete
               - Visibility toggle (eye icon) per node — hides subtree.
               - Lock toggle (lock icon) per node — blocks selection of subtree.
               - Group node shows child count badge when collapsed.

             GROUPS THAT WILL BE AUTO-CREATED
             ──────────────────────────────────
             Once the tree exists, these importers/systems create groups
             automatically rather than dumping everything at root level:

               - GLTF import      → one group per GLTF scene node hierarchy,
                                    preserving the original node tree.
               - OBJ import       → one group per imported file if it contains
                                    multiple mesh objects (o/g statements).
               - Grammar generate → one group per generation run, named
                                    "Grammar_001", "Grammar_002", etc.
                                    All placed primitives go inside.
               - Paste            → pasted objects placed in a "Pasted_001"
                                    group so they can be moved/deleted together.
               - Asset Library    → "Add to Scene" creates a group if the
                                    asset contains multiple sub-meshes.

             SCENE SAVE/LOAD (ProjectFile)
             ──────────────────────────────
             ProjectFile must serialise parentId per object.
             Load order must reconstruct parent-before-child (sort by depth).
             Group nodes (mesh == nullptr) serialised as type "group".

             NOTE ON ORDERING
             ─────────────────
             This refactor should be done after Refactor B (grammar-ui split)
             because grammar generation auto-grouping requires the grammar-ui
             library to call Scene::createGroup() — that interface must be
             stable first. It should be done before Phase 11 (Connection
             Volumes) because connection volumes are per-object and the
             parent-child transform chain affects their world positions.


Refactor F  ✓  Status Bar — Always-Docked Bottom
             Replaced floating drawStatsOverlay() with drawStatusBar().
             Pinned to bottom of OS window (statusBarHeight = 22px).
             Left: project filename. Centre: object/selection count + mode.
             Right: FPS right-aligned. statusBarHeight in EditorUIState for layout.
             Toast overlay kept for save/load confirmations.

Refactor G  ✓  Scene Panel — Always-Docked Left
             Replaced floating Scene window with drawScenePanel() in EditorUI.
             Always-docked left strip, 300px, zero rounding, pinned below toolbar.
             Outliner + transform inspector driven by EditorUIState fields.
             App fills fields in update(), drains clicks/commits in render().
             Action buttons moved to App::drawSceneActions() child region.
             scenePanelWidth in EditorUIState for viewport/gizmo offset.

Refactor H  Multi-Monitor Support (ImGui Viewports)
             Currently ImGuiConfigFlags_ViewportsEnable is not set, so all
             ImGui windows are confined to the main GLFW window and cannot
             be dragged to a second monitor.

             IMPLEMENTATION
             ───────────────
             In App::init(), add to ImGui config flags:
               io.ConfigFlags |= ImGuiConfigFlags_ViewportsEnable;
             This enables platform windows — any undocked ImGui window
             becomes its own OS-level floating window and can be placed
             on any monitor.

             Style fix required when viewports are enabled:
               style.WindowRounding = 0.0f;
               style.Colors[ImGuiCol_WindowBg].w = 1.0f;

             Which panels can float to other monitors:
               - Asset Library        ✓  good candidate for second monitor
               - Grammar View         ✓  heavy panel, benefits from own monitor
               - Graph Connection View (Phase 15) ✓  node graphs need space
               - Scene panel          ✗  locked left, cannot undock (Refactor G)
               - Toolbar              ✗  fixed, cannot undock
               - Status bar           ✗  fixed, cannot undock

             NOTE: ViewportsEnable requires the GLFW backend to support
             multi-viewport. Verify imgui_impl_glfw.cpp version supports
             this before enabling.

Phase A     GLTF Export with Vertex Colour Information
             Grammar-generated and hand-assembled scenes must be exportable
             as GLTF files with per-object colour baked in.

             SCOPE
             ──────
             Export full scene or selected objects to .gltf / .glb:
               - Each SceneObject becomes a GLTF mesh node.
               - World transform written to node transform, respecting
                 parent hierarchy from Refactor E.
               - Per-object colour written as a KHR_materials_unlit
                 material with baseColorFactor = [r, g, b, 1.0].
                 Supported by Blender, UE5, Unity, all major DCC tools.
               - Grammar primitive colours (procedural cube colours) are
                 included, so generated layouts export with colour coding.
               - Groups (Refactor E) map to GLTF node hierarchy naturally.
             Implement GltfExporter.h/.cpp in src/ — minimal GLTF JSON
             writer, no external library needed.
             Offer .gltf (separate .bin sidecar) and .glb (single binary).
             Add to File menu:
               Export Scene as GLTF...
               Export Selection as GLTF...
             NOTE: This replaces the OBJ Export placeholder (old Phase 5b /
             new Phase 13). GLTF is the better target — it carries colour,
             hierarchy, and is the industry standard interchange format.

Phase B     Remove Hardcoded Tiles and Example Grammar
             GrammarView::registerPrims() hardcodes 6 tile types
             (HStraight, VStraight, CornerTL/TR/BL/BR) in code.
             The "Hardcoded demo" checkbox also references a fixed example.
             These must be removed once asset-driven workflows exist.

             WHAT REPLACES THEM
             ────────────────────
             Tiles are defined by the asset library + connector volumes,
             not by code. The grammar learns tile types from imported meshes
             and their connector definitions (Phase 11 + Phase 12).

             Intermediate step (do after Phase 11, before Phase 12):
               - Remove registerPrims() and all hardcoded colour/socket data.
               - Remove "Hardcoded demo" checkbox from grammar panel.
               - Grammar panel shows an empty state:
                 "Import meshes, define their connectors, then generate."
               - Seed / min/max sliders remain.
             Full removal of the grid-based grammar is part of Phase 12.

Phase 11    Connection Volumes
             Box gizmo on each SceneObject with resize/move/rotate handles.
             Defines the physical connector region used for snapping.
             Use ImGuizmo library rather than building handle interaction
             from scratch.
             Store connection volume in SceneObject alongside socket list.

Phase 12    Free-Form Generation                          *** PIVOT POINT ***
             Complete rewrite of the generator.
             Grid-based (integer cells, cardinal sockets)
               → world-space (sockets as positions + normals, connector snapping).
             Everything before this phase works on the grid system.
             Everything after works on physical world-space connectors.
             Grid remains useful for measurement/alignment but is no longer
             enforced by the generator.
             GrammarInducer updated to infer world-space rules from
             hand-placed example scenes.

Phase 13    ~~OBJ Export~~  →  SUPERSEDED by Phase A (GLTF Export)
             GLTF carries colour, hierarchy, and is the industry standard.
             OBJ export will not be implemented. See Phase A above.

Phase 14    Multiple Grammars in Scene
             Multiple grammar roots or rule sets in a single scene.
             Each grammar manages its own sub-graph of SceneObjects.
             Follows naturally from SceneObject being the right abstraction.

Phase 15    Graph Connection View
             Separate editor mode (or sub-panel) showing the node graph
             of placed assets and their connectors.
             Display: mesh thumbnail, connector volumes, connection edges.
             Node graph UI — use imnodes library.

Phase 16    Icons
             SVG/PNG icons for all 43 commands in COMMANDS.txt.
             Load as OpenGL textures and display via ImGui::Image in
             toolbar and panel buttons.
             Icon sheet approach (single texture atlas, UV per icon).

Phase 100   Large Worlds with Asset Packs
             Root folder with nested sub-folders of assets
             (buildings, pathways, rivers, lakes, etc.)
             Each folder has a grammar rules definition file.
             Open vs closed loop distinction:
               - Rivers    → open loop, can flow into lakes
               - Buildings → closed loop
               - Pathways  → can join rivers, lakes, buildings
             Current grammar architecture maps directly to this —
             each folder's rules file is a Grammar definition.


================================================================================
  THE MERRELL REPLACEMENT — STRATEGIC DECISION
================================================================================

  Reference paper: docs/Merrell2023_ExampleBasedProcModelGraphGrammars.pdf
  Paul Merrell, "Example-Based Procedural Modeling Using Graph Grammars"
  ACM Trans. Graph. 42, 4, Article 1 (August 2023)

  WHAT THIS MEANS FOR THE PROJECT
  The current generator (Grammar.h/.cpp, GrammarInducer.h/.cpp) uses a
  hand-coded grid-based tile compatibility system. This was always going
  to be replaced by Phase 12 (Free-Form Generation).

  The Merrell paper SOLVES the design problem that was listed in this
  roadmap. It provides a complete, published algorithm for automatically
  generating a graph grammar from an example shape, with no hand-crafted
  rules. The generated grammar produces a wide range of locally similar
  shapes, handling closed loops correctly — which all prior methods fail to
  do including our current grid approach.

  DECISION: Replace the current grammar system entirely with an
  implementation of the Merrell DPO graph grammar algorithm.
  The editor, scene, asset library, and all src/ code are unaffected.
  Only lib/grammar-core/ is replaced. Grammar-ui gets updated panels.

  WHY MERRELL IS THE RIGHT CHOICE
  - Handles closed loops — the core failure of our current system.
  - Not limited to specific shapes. Works on arbitrary polygonal input.
  - Requires only a small example input to generalise from.
  - Proven in 2D and extended to 3D (Section 7 of paper).
  - Fast: Castle example (88 rules, 4k iterations) runs in 9.5s on CPU.
  - Rules are invertible (DPO property): constructive and destructive
    application both work, maps cleanly to undo/redo.
  - Full pseudocode in paper (Algorithms 1, 2, 3). Implementable.

  WHAT IS PRESERVED VS REPLACED
  Preserved:
    HalfEdgeMesh.h/.cpp        directly relevant; Merrell primitives
                               map to half-edge graph cuts.
    All of src/                editor, scene, renderer, asset library
                               untouched.
    lib/grammar-ui/ concept    updated to drive new algorithm.
  Replaced:
    Grammar.h/.cpp             grid-based WFC-style generation loop.
    GrammarInducer.h/.cpp      tile compatibility rule learner.
    Grid cell / cardinal socket direction as primary representation.
    Replaced by labeled half-edges and boundary strings.


================================================================================
  MERRELL IMPLEMENTATION ROADMAP
================================================================================

  Work through these phases in order. Each has a testable deliverable.
  All new code lives in lib/grammar-core/ (restructured).
  Reference throughout: docs/Merrell2023_ExampleBasedProcModelGraphGrammars.pdf

  ─────────────────────────────────────────────────────────────────────────────
  IMPLEMENTATION STRATEGY — GRID-FIRST, FREE-FORM LATER
  ────────────────────────────────────────────────────────
  MG-0 through MG-4 can be implemented on top of the existing tile system.
  The Merrell algorithm operates on graphs (nodes, edges, labels) and is
  purely topological — it knows nothing about metres or grid cells. The tiles
  become the labeled faces. Grid cardinal directions become edge angles.

  What is deferred to later phases:
    - Arbitrary polygon input (MG-1 generalisation)
    - Free-form vertex position solving (Algorithm 3 Section 6.2 linear system)
    - 3D extension (MG-6)

  ⚠️  CRITICAL DESIGN NOTE — read before touching MerrellGraph or DPORule:
  Don't let the grid assumption bake too deep into MerrellGraph or DPORule
  data structures. Keep edge labels abstract (l, r, θ) from the start even
  if θ is currently always a multiple of 90°. That way the transition to
  arbitrary angles later is a data change, not a structural one.

  ⚠️  COMPUTE SHADER NOTE — read before implementing any MG algorithm:
  Where possible, GPU compute shaders should be used for the heavy MG
  operations. The most promising candidates are:
    - Algorithm 2 (findMatchingGroups): boundary string matching across the
      entire hierarchy is embarrassingly parallel — each candidate graph in
      the hierarchy can be tested against each boundary substring independently.
    - Algorithm 3 (generation): rule matching (subgraph isomorphism attempts)
      across many candidate positions in G can be parallelised per-rule.
    - Position solving (Sec 6.2): the linear system Ax = b is a natural
      fit for a GPU solver (each vertex position is independent given fixed
      neighbours).
  Implementation approach:
    - Keep the CPU reference implementation correct and working first.
    - GPU path lives alongside it, selected at runtime if GL_ARB_compute_shader
      is available (OpenGL 4.3+). Fall back to CPU silently if not.
    - Compute shaders go in shaders/compute/ — one .glsl file per operation.
    - Data passed via SSBOs (Shader Storage Buffer Objects): pack graph topology
      into flat int arrays (vertex ids, half-edge next/twin/face, label indices)
      for efficient GPU access.
    - String labels (l, r) are interned to int indices before upload so the
      GPU only works with integers, not variable-length strings.

  Phase MG-0  ✓  Study & Data Structures  [compiler errors fixed in MG-1 pass]
             Three new headers created in lib/grammar-core/:
               MerrellGraph.h/.cpp  — EdgeLabel (l, r, θ as float ⚠️), TurnType,
                                      BoundaryString, MGHalfEdge, MGVertex, MGFace,
                                      MerrellGraph with factory/accessor/boundary methods.
               DPORule.h/.cpp       — GraphMorphism (vertex/halfEdge/face maps),
                                      RuleKind enum, DPORule (L, I, R graphs + φL φR),
                                      RuleMatch result type.
               MerrellGrammar.h/.cpp — TileInput (grid-first ⚠️), PlacedFace,
                                      GenerationResult, GrammarSettings, HierarchyNode,
                                      MerrellGrammar controller with all algorithm
                                      entry points stubbed (TODO MG-1 through MG-4).
             All three files compile as stubs. CMakeLists.txt updated.
             Key design decisions locked in:
               θ is float throughout — never int or enum.
               pos is vec2 for now — comment marks where to promote to vec3 (MG-6).
               loadFromTiles() is the grid-first entry point — loadFromShape() declared
               but unimplemented until MG-5.
               No grid coordinates anywhere in MerrellGraph or DPORule.
  ─────────────────────────────────────────────────────────────────────────────
  Read the paper. Key sections before writing a single line of code:
    Sec 3.3   half-edges, edge labels (l, r, θ), boundary string ∂G,
              positive ∧ and negative ∨ turns.
    Sec 4.1   Disassembly: cutting input into primitives.
    Sec 4.2   Branch gluing and loop gluing rules.
    Sec 4.3   Graph hierarchy (abstract model).
    Sec 5.1   Algorithm 1: Find Grammar From Primitives.
    Sec 5.3   Algorithm 2: findMatchingGroups.
    Sec 6     Algorithm 3: Generate Graph Drawing From Grammar.
    Sec 7     Extension to 3D.

  Core data structures to design:
    HalfEdge        label (l, r, θ), directed, paired with opposite half-edge
    MerrellGraph    set of vertices + half-edges + face labels
    BoundaryString  circular sequence of half-edge labels and ∧ ∨ turns
    DPORule         left graph L, right graph R, interface I, morphisms φL φR
    GrammarRuleSet  vector<DPORule> + starter rules

  ─────────────────────────────────────────────────────────────────────────────
  Phase MG-1  ✓  Input Representation & Disassembly  (Section 4.1)
  ─────────────────────────────────────────────────────────────────────────────
  MG-0 compiler errors fixed (M_PI define, MeshData forward decl, clear()).
  loadFromTiles(socketDefs, tiles) implemented in MerrellGrammar.cpp:
    - TileSocketDef added: one entry per unique tile label with socket dirs.
    - One canonical MerrellGraph primitive built per unique tile label.
    - Each primitive: 4 vertices (unit square), 4 half-edge pairs, 1 face.
    - Socket edges labelled l=tile, r="open"; sealed edges r="exterior".
    - theta set via gridDirToTheta() -- float, multiples of pi/2 for now.
    - linkFaceLoop() wires next/prev/face pointers for the CCW boundary walk.
  boundaryOf(faceId) implemented in MerrellGraph.cpp:
    - Walks face half-edge loop via next pointers.
    - At each vertex, computes turn type from cross product of consecutive
      edge direction vectors (cos theta, sin theta).
    - Produces BoundaryString with alternating edge/turn elements.
    - Each rectangular primitive produces 4 edges and 4 positive turns
      (total turn count = +4, isComplete() = true).
  BoundaryString::toString() added for debug output.
  MerrellGraph::clear() added (resets vectors and id counters).
  README.md added to project root (from user-provided file).

  ─────────────────────────────────────────────────────────────────────────────
  Phase MG-2  ✓  Graph Hierarchy Construction  (Section 4.3)
  ─────────────────────────────────────────────────────────────────────────────
  BoundaryString operations implemented:
    isCircularlyEqual(): O(n^2) rotation search, compares element-by-element.
    cancelTurns(): removes adjacent opposite-sign turn pairs; loops until
      stable; handles wrap-around (last+first pair cancellation).
    rotated(offset): returns a copy starting at element `offset` (used by
      Algorithm 2 substring matching in MG-3).
    outerBoundary(): walks all half-edges with r="open" or twin==-1, chains
      them by vertex into a CCW boundary walk with turn annotations.
  MerrellGraph gluing helpers:
    mergeVertices(from, to): welds two vertices by reassigning all half-edge
      starts; removes the source vertex.
    removeHalfEdgePair(heId): patches next/prev of neighbours; erases both
      half-edges.
    appendGraph(dst, src, offsets): copies a graph with id offsetting for
      combining two graphs into one (used by loop gluing).
  MG-2 hierarchy construction:
    buildHierarchy() seeds gen-0 from primitives, then iterates generations
      calling tryLoopGluings() + tryBranchGluings() until no new nodes appear
      or maxHierarchyGen is reached.
    tryLoopGluings(gen): for all pairs (A,B) at this generation, finds all
      pairs of complementary open edges (theta diff = pi), runs loopGlue(),
      deduplicates by boundary string toString(), adds new nodes to hierarchy.
    tryBranchGluings: TODO (branch gluing, Sec 4.2 type 2).
  NOTE: branch gluings are the next step before MG-3. The current
  loop-only hierarchy is correct but incomplete -- branch gluings produce
  the T-junctions and more complex configs needed for rule extraction.

  ─────────────────────────────────────────────────────────────────────────────
  Phase MG-3  ✓  Grammar Extraction  (Algorithm 1 + Algorithm 2, Section 5)
  ─────────────────────────────────────────────────────────────────────────────
  Extract DPO production rules from the hierarchy. Heart of the algorithm.

  Algorithm 1 — for each graph G (simple to complex):
    1. Try Algorithm 2 to find a rule simplifying G.
    2. If found: G is reducible. Mark it, remove from frontier.
    3. If G has no complete descendants (Sec 5.6): prune G + descendants.
    4. Continue until hierarchy exhausted or rule count limit reached.

  Algorithm 2 — findMatchingGroups(∂L):
    Recursive divide-and-conquer on the boundary string.
    For each graph R in hierarchy: try to match ∂R to ∨ⁿ ∂L ∧ⁿ.
    Recursively match each unmatched substring. Splice results together.

  Special cases:
    - Starter rules (Sec 5.3.1): complete graph → empty graph ∅.
    - Stubs (Sec 5.5): one-half-edge graphs, very useful for pruning.
    - Descendant reduction (Sec 5.4): R is descendant of L — restructure.
    - Pruning (Sec 5.6): graphs with no complete irreducible descendants.

  DELIVERABLE: given rectangle input, automatically produce the 5-rule
  grammar from Fig. 5 of the paper.

  ─────────────────────────────────────────────────────────────────────────────
  Phase MG-4  Shape Generation  (Algorithm 3, Section 6)
  ─────────────────────────────────────────────────────────────────────────────
  Use the extracted grammar to generate new shapes.

  Algorithm 3:
    1. Start: empty graph ∅.
    2. For N iterations:
       a. Pick a DPO rule. Apply constructively (R→L) or destructively
          (L→R) — no preference. Match via planar subgraph isomorphism.
       b. Propose vertex positions (Sec 6.2):
          Build linear system Ax=b from edge angle constraints.
          Find nullspace basis KA. Sample from x̂ + KA·Λ.
          If overconstrained: free adjacent vertices iteratively.
       c. Accept if: angles correct, edge lengths in range, planar.
          Optional: Metropolis-Hastings cost function (Phase MG-8).
    3. Output: complete graph drawing (angle graph with vertex positions).

  DELIVERABLE: given 5-rule rectangle grammar, generate new shapes
  similar to Fig. 8(a). Render as flat geometry on Y=0 in viewport.

  ─────────────────────────────────────────────────────────────────────────────

  ─────────────────────────────────────────────────────────────────────────────
  Phase MG-2.5  ✓  Graph Viewer -- imnodes Node Graph Editor  [CONFIRMED RUNNING]
  imnodes vendored: third_party/imnodes/imnodes.h + imnodes.cpp
  Removed from vcpkg.json. Added to CMakeLists SOURCES + include dirs.
  ToolbarSection brace-init fixed: both App.cpp calls use grammarOnly() factory.
  ─────────────────────────────────────────────────────────────────────────────
  Add a new editor view that shows the output of MG-2 (and MG-1) as an
  interactive node graph, so hierarchy splits can be verified visually
  before continuing to MG-3. This is a debugging and validation tool,
  not a permanent part of the generation pipeline.

  WHY THIS EXISTS
  ─────────────────
  MG-2 graph hierarchy construction is the most opaque step -- it produces
  a DAG of MerrellGraph nodes whose correctness is hard to verify from
  console output alone. A visual node graph where you can see:
    - Each primitive (gen 0) as a node
    - Each gluing result as a child node connected to its parents
    - Boundary strings as edge labels between nodes
    - Whether each node is complete (closed loop), pruned, or live
  ...makes it immediately obvious if the hierarchy is being built correctly.

  LIBRARY
  ─────────────
  Use imnodes (https://github.com/Nelarius/imnodes) -- a lightweight ImGui
  extension for node graph rendering. Add via vcpkg: "imnodes".
  imnodes renders nodes and connections inside a standard ImGui window.
  It handles pan/zoom, node dragging, and connection rendering.

  VIEWS REQUIRED
  ─────────────────
  The graph viewer panel must support switching between these data views:

  1. PRIMITIVE VIEW (MG-1 output)
     - One node per MerrellGraph primitive.
     - Node header = face label (tile name).
     - Node body: list of half-edges with their labels (l, r, theta).
     - Node body: boundary string text: "E0^E1^E2^E3^" etc.
     - Colour-coded: socket edges (r="open") vs sealed edges (r="exterior").

  2. HIERARCHY VIEW (MG-2 output)
     - One node per HierarchyNode, laid out by generation (columns).
     - Gen 0 = left column (primitives). Gen 1, 2, ... = right columns.
     - Node header = "Gen N: <boundary string>"
     - Node body: face count, edge count, isComplete badge.
     - Connections: parent->child edges showing which gluings produced it.
     - Pruned nodes shown greyed out.
     - Complete nodes (closed loops) shown with green border.

  3. RULE VIEW (MG-3 output -- used in MG-5 panel)
     - One node per DPORule, split into L and R sub-nodes.
     - L node: left graph layout (the larger pattern).
     - R node: right graph layout (the smaller replacement).
     - I interface shown as shared edges between L and R.
     - Rule kind shown in header (LoopGlue, BranchGlue, Starter, etc.).
     - Morphisms phi_L and phi_R shown as coloured edge connections.

  ⚠️  DEBUG VIEW NOTE (see below for full list of inspectable types)
  All five core types must be inspectable in the graph viewer panel:
    HalfEdge       -- label (l, r, theta), directed, paired with twin
    MerrellGraph   -- set of vertices + half-edges + face labels
    BoundaryString -- circular sequence of half-edge labels and turns
    DPORule        -- L graph, R graph, interface I, morphisms phi_L phi_R
    GrammarRuleSet -- vector<DPORule> + starter rules

  IMPLEMENTATION
  ─────────────────
  New files:
    lib/grammar-ui/GraphViewer.h/.cpp   -- imnodes-based viewer panel
  New EditorMode or sub-panel inside GRAPH_GRAMMAR mode.
  Registered as a toolbar section (like GrammarView).
  Add imnodes to vcpkg.json and CMakeLists.txt.
  GraphViewer reads MerrellGrammar::primitives(), hierarchy(), rules()
  directly -- no data copying needed since it's read-only display.


  ─────────────────────────────────────────────────────────────────────────────────
  Phase MG-2.5  ✓  Graph Viewer -- imnodes node graph panel  [CONFIRMED RUNNING]
  GraphViewer.h/.cpp implemented: 3 tabs (Primitives/Hierarchy/Rules).
  imnodes API fixed: SetNodeEditorSpacePos, PopColorStyle() with no-arg.
  imnodes include in header. Wired into App::render() + App::init().
  All 5 inspectable types rendered: HalfEdge table, MerrellGraph canvas,
  BoundaryString inline chain, DPORule L/I/R layout, GrammarRuleSet list.
  ─────────────────────────────────────────────────────────────────────────────────
  Goal: add a new editor panel that lets us visually inspect the output of
  MG-1 and MG-2 before committing to MG-3. MG-2 hierarchy construction is
  the most opaque step -- a visual node graph makes mismatches obvious
  immediately rather than burying them in console output.

  LIBRARY
    Use imnodes (github.com/Nelarius/imnodes). Lightweight ImGui extension
    for node-graph rendering. Pan/zoom, node drag, bezier connections.
    Add via vcpkg: add "imnodes" to vcpkg.json.
    Add to CMakeLists: find_package(imnodes CONFIG REQUIRED),
    target_link_libraries(... imnodes::imnodes).

  FIVE INSPECTABLE TYPES
  The viewer must be able to display any of these on demand:

    HalfEdge
      Each directed half-edge shown as a node.
      Fields: id, twin id, next/prev, vertex, face, label (l, r, theta).
      Colour-coded: "open" edges = teal, "exterior" = grey, cut (twin==-1) = red.

    MerrellGraph
      One node-graph canvas per MerrellGraph.
      Vertex nodes connected by labelled half-edge arrows.
      Face label shown as a badge on the face centroid.
      Boundary string displayed as a text overlay: "E0^E1^E2^E3^".

    BoundaryString
      Shown as a horizontal chain of elements.
      Edge elements = coloured boxes with label and theta.
      Turn elements = ^ or v symbols between boxes.
      Complete status badge (green checkmark if |turns| == 4).

    DPORule
      Three sub-graphs side by side: L (left) -- I (interface) -- R (right).
      Morphism edges phi_L and phi_R shown as coloured connections
      between I nodes and their images in L and R.
      Rule kind (LoopGlue / BranchGlue / Starter / Stub / General) in header.

    GrammarRuleSet
      List view of all extracted DPORule objects.
      Click any rule to expand its L/I/R sub-graph view.
      Starter rules pinned at top. Filter by RuleKind.

  VIEWS (tab strip within the panel)
    Tab 1 -- PRIMITIVES (MG-1 output)
      Grid of MerrellGraph nodes, one per primitive.
      Shows: face label, degree, boundary string, socket edges highlighted.
    Tab 2 -- HIERARCHY (MG-2 output)
      DAG layout: gen-0 left, gen-N right.
      Nodes: HierarchyNode.graph (compact view), isComplete badge, pruned flag.
      Edges: parent->child connections showing which gluings produced each node.
    Tab 3 -- RULES (MG-3 output)
      GrammarRuleSet view as above.

  IMPLEMENTATION FILES
    lib/grammar-ui/GraphViewer.h   -- MerrellGrammar const& ref, drawPanel()
    lib/grammar-ui/GraphViewer.cpp -- imnodes rendering for all 5 types
  Register as a new panel alongside GrammarView.
  GraphViewer holds a const pointer to MerrellGrammar -- read-only, no copy.

  Phase MG-5  Editor Integration
  ─────────────────────────────────────────────────────────────────────────────
  Connect new Merrell core to the editor's grammar-ui layer.

  lib/grammar-core/ public API:
    MerrellGrammar::loadFromShape(MeshAsset&)   extract primitives + rules
    MerrellGrammar::generate(N, seed)            run Algorithm 3
    MerrellGrammar::saveRules(path)              serialise rules to JSON
    MerrellGrammar::loadRules(path)              load rules from JSON

  lib/grammar-ui/ panel updates:
    "Example Input"  — select shape from Asset Library as grammar example.
    "Grammar"        — rule count, primitive count, hierarchy stats.
                       "Extract Grammar" button → background TaskSystem task.
    "Generate"       — N iterations slider, seed, edge length constraints.
                       "Generate" button → background TaskSystem task.
    "Rules"          — list extracted DPO rules, debug individual rule apply.

  Scene integration:
    - Each face in graph drawing → SceneObject placed in scene.
    - Face label → mesh asset lookup in Asset Library.
    - All generated objects → placed in "Grammar_NNN" group (Refactor E).

  Legacy code retirement (on successful MG-5 completion):
    Grammar.h/.cpp, GrammarInducer.h/.cpp → archived to legacy/ folder.
    HalfEdgeMesh.h/.cpp → kept, adapted.
    Hardcoded tiles (Phase B) → removed at same time.

  ─────────────────────────────────────────────────────────────────────────────
  Phase MG-6  3D Extension  (Section 7)
  ─────────────────────────────────────────────────────────────────────────────
  Extend from 2D to full 3D shapes.

  Key 3D differences:
    - ∂G is a 2D boundary graph, not a 1D string.
    - Boundary matching: graph isomorphism instead of string matching.
    - Splice: swap connections between edges along shared face.
    - Loop gluing: half-edges sharing a common face turning ±360° around
      that face's normal.
    - Vertex positions are 3D; edge constraints encode 3D angles.
  Start with extruded 2D profiles (buildings, walls) where 2D grammar
  already gives useful 3D results, then tackle fully 3D meshes.

  ─────────────────────────────────────────────────────────────────────────────
  Phase MG-7  Decorations  (Appendix B)
  ─────────────────────────────────────────────────────────────────────────────
  Post-processing step: place mesh assets at faces, edges, vertices.
    - Face label → mesh from Asset Library (wall, window, roof, etc.)
    - Edge decoration: tile an asset repeatedly along edge length.
    - Vertex decoration: place asset at corners.
    - Bending (Appendix B): subdivide edges, randomly bend segments,
      solve final positions via linear least squares preserving cycles.

  ─────────────────────────────────────────────────────────────────────────────
  Phase MG-8  Metropolis-Hastings Cost Control  (Section 6.3, optional)
  ─────────────────────────────────────────────────────────────────────────────
  Optional acceptance criterion for user control over large-scale properties.
    - Accept/reject each grammar step based on cost function delta.
    - Useful cost functions: target density, edge label frequency,
      connectivity constraints.
    - Expose as sliders in grammar-ui panel.
    - Addresses the large-scale constraint limitation noted in Sec 9.3.


================================================================================
  ARCHITECTURE — CURRENT FILE MAP
================================================================================

  lib/grammar-core/         (target state after Refactor B + MG-5)
    MerrellGrammar.h/.cpp   DPO graph grammar: Algorithm 1+2+3 (Merrell 2023)
    MerrellGraph.h/.cpp     Half-edge graph, boundary string, gluing ops.
    HalfEdgeMesh.h/.cpp     Mesh topology — adapted for MerrellGraph use.
    legacy/                 Archived originals (not compiled):
      Grammar.h/.cpp        Old grid-based generation — superseded.
      GrammarInducer.h/.cpp Old tile rule learner — superseded.

  lib/grammar-ui/           (target state after Refactor B + MG-5)
    GrammarView.h/.cpp      ImGui panels: example input, extract, generate.
    GrammarRulesView.h/.cpp ImGui panel: DPO rule inspector + debugger.

  docs/
    Merrell2023_ExampleBasedProcModelGraphGrammars.pdf   Reference paper.

  src/                      Editor core — knows nothing about grammar internals.
    App.h/.cpp              Main loop, mode switching, event routing.
    EditorUI.h/.cpp         Toolbar, menu bar, stats overlay, toast.
    Scene.h/.cpp            Single source of truth for placed objects.
    SceneObject.h           Core scene entity.
    Renderer.h/.cpp         All GL. Draws scene via drawSceneObject().
    AssetLibrary.h/.cpp     Persistent editor asset store.
    AssetLibraryView.h/.cpp ImGui window for asset library.
    ProjectFile.h/.cpp      JSON scene save/load.
    CommandHistory.h        Undo/redo stack.
    MeshAsset.h/.cpp        GPU mesh wrapper.
    MeshMerge.h/.cpp        Merge + weld operations.
    ObjImporter.h/.cpp      .obj → MeshAsset. No GL dependency.
    GltfImporter.h/.cpp     .gltf/.glb → MeshAsset.
    ThumbnailRenderer.h/.cpp Offscreen FBO for asset previews.
    FileDialog.h/.cpp       Native Windows file picker.
    InputRouter.h/.cpp      Mouse/keyboard ownership routing.
    main.cpp                Entry point.

  shaders/
    grid.vert / grid.frag   Infinite procedural grid, 4-level LOD, concrete.
    mesh.vert / mesh.frag   Lit mesh rendering.

================================================================================
